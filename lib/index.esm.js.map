{
  "version": 3,
  "sources": ["../src/core/ThreeRoot.ts", "../src/core/ThreeVirtualKeyboardRoot.ts", "../src/drivers/MouseRayPointerSource.ts", "../src/drivers/ThreeRayPointerDriver.ts", "../src/drivers/XRControllerRayPointerSource.ts"],
  "sourcesContent": ["import type { PointerStyleHandler, Widget, Theme } from '@rafern/canvas-ui';\nimport type { TransformAlgorithm } from './TransformAlgorithm';\nimport { Root } from '@rafern/canvas-ui';\n\nimport {\n    CanvasTexture, PlaneGeometry, MeshBasicMaterial, Mesh, Vector2, Object3D\n} from 'three';\n\n/**\n * A {@link Root} that also manages a three.js Mesh so that it can be added to a\n * Scene.\n *\n * @category Core\n */\nexport class ThreeRoot extends Root {\n    /** The texture with the canvas data. */\n    private texture: CanvasTexture;\n    /**\n     * The textured Mesh to be used for a Scene. Not actually a Mesh, but an\n     * Object3D which contains a mesh so that the mesh can be resized without\n     * interfering with the {@link transformAlgorithm}.\n     */\n    readonly mesh: Object3D;\n    /**\n     * Transform algorithm; decides how to position the canvas' mesh in the\n     * world. Can be changed later and is called on update.\n     */\n    transformAlgorithm: TransformAlgorithm | null;\n\n    /**\n     * Creates a new ThreeRoot.\n     *\n     * Sets {@link child}, {@link pointerStyleHandler},\n     * {@link transformAlgorithm} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}.\n     *\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(child: Widget, pointerStyleHandler: PointerStyleHandler | null = null, transformAlgorithm: TransformAlgorithm | null = null, theme?: Theme) {\n        super(child, pointerStyleHandler, theme);\n\n        // Create texture out of canvas. For now, the texture is invalid\n        this.texture = new CanvasTexture(this.viewport.canvas);\n\n        // Create a planar mesh out of internal canvas\n        const meshGeometry = new PlaneGeometry();\n        const meshMaterial = new MeshBasicMaterial({ map: this.texture });\n        meshMaterial.transparent = true;\n        const internalMesh = new Mesh(meshGeometry, meshMaterial);\n\n        // Wrap mesh in Object3D so it can be transformed independently\n        this.mesh = new Object3D();\n        this.mesh.add(internalMesh);\n\n        // Transforms algorithm\n        this.transformAlgorithm = transformAlgorithm;\n    }\n\n    override set enabled(enabled: boolean) {\n        super.enabled = enabled;\n        this.mesh.visible = enabled;\n    }\n\n    override get enabled(): boolean {\n        return super.enabled;\n    }\n\n    override resolveLayout(): boolean {\n        const resized = super.resolveLayout();\n\n        // Resize mesh and texture if needed\n        if(resized) {\n            const [width, height] = this.dimensions;\n            const [canvasWidth, canvasHeight] = this.canvasDimensions;\n            const wRatio = width / canvasWidth;\n            const hRatio = height / canvasHeight;\n            this.texture.offset = new Vector2(0, 1 - hRatio);\n            this.texture.repeat = new Vector2(wRatio, hRatio);\n\n            this.mesh.children[0].scale.fromArray([width, height, 1]);\n        }\n\n        return resized;\n    }\n\n    override paint(): boolean {\n        const wasDirty = super.paint();\n\n        // Update texture if needed\n        if(wasDirty)\n            this.texture.needsUpdate = true;\n\n        // Update transforms of mesh\n        if(this.transformAlgorithm !== null) {\n            this.transformAlgorithm(this);\n\n            // Update mesh world matrix\n            this.mesh.matrixWorldNeedsUpdate = true;\n        }\n\n        return wasDirty;\n    }\n}\n", "import type { Theme, KeyboardDriver, VirtualKeyboardTemplate, PointerStyleHandler } from '@rafern/canvas-ui';\nimport { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '@rafern/canvas-ui';\nimport type { TransformAlgorithm } from './TransformAlgorithm';\nimport { ThreeRoot } from './ThreeRoot';\n\n/**\n * A {@link VirtualKeyboardRoot} but it extends {@link ThreeRoot} instead of\n * {@link Root}, so it can be used for three.js.\n *\n * @category Core\n */\nexport class ThreeVirtualKeyboardRoot extends ThreeRoot {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new ThreeVirtualKeyboardRoot.\n     *\n     * Sets {@link child} to a new {@link VirtualKeyboard} with the given\n     * keyboard and {@link VirtualKeyboardTemplate | keyboard template},\n     * {@link pointerStyleHandler}, {@link transformAlgorithm} and\n     * {@link child}'s {@link Widget.inheritedTheme | inherited theme}.\n     *\n     * @param keyboardTemplate By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, pointerStyleHandler: PointerStyleHandler | null = null, transformAlgorithm: TransformAlgorithm | null = null, theme?: Theme) {\n        super(new VirtualKeyboard(keyboardDriver, keyboardTemplate), pointerStyleHandler, transformAlgorithm, theme);\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update the visibility of this root; if the keyboard driver has no focused\n     * root, then the root is disabled, else, it is enabled. Call this method\n     * on every frame to automatically enable/disable the root if needed\n     */\n    updateVisibility(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.getFocusedRoot() !== null;\n    }\n}", "import { /* tree-shaking no-side-effects-when-called */ Raycaster, Camera } from 'three';\nimport type { RayPointerSource, RayPointerDriver, PointerHint } from '@rafern/canvas-ui';\nimport { getPointerEventNormPos } from '@rafern/canvas-ui';\n\nexport class MouseRayPointerSource implements RayPointerSource {\n    private raycaster: Raycaster = new Raycaster();\n    private driver: RayPointerDriver | null = null;\n    private _pointer = -1; // TODO multi-pointer support\n\n    constructor(camera: Camera, domElem: HTMLElement) {\n        this.raycaster.camera = camera;\n\n        // Add listeners to DOM element\n        domElem.addEventListener('pointermove', (event: PointerEvent) => {\n            if(event.isPrimary)\n                this.castRay(...getPointerEventNormPos(event, domElem), event.buttons, event.shiftKey, event.ctrlKey, event.altKey);\n        });\n        domElem.addEventListener('pointerdown', (event: PointerEvent) => {\n            if(event.isPrimary)\n                this.castRay(...getPointerEventNormPos(event, domElem), event.buttons, event.shiftKey, event.ctrlKey, event.altKey);\n        });\n        domElem.addEventListener('pointerup', (event: PointerEvent) => {\n            if(event.isPrimary)\n                this.castRay(...getPointerEventNormPos(event, domElem), event.buttons, event.shiftKey, event.ctrlKey, event.altKey);\n        });\n        domElem.addEventListener('pointerleave', (event: PointerEvent) => {\n            if(event.isPrimary && this.driver !== null)\n                this.driver.leaveAnyPointer(this._pointer);\n        });\n    }\n\n    get pointer(): number | null {\n        if(this._pointer === -1)\n            return null;\n        else\n            return this._pointer;\n    }\n\n    private castRay(xNorm: number, yNorm: number, pressing: number | null, shift: boolean, ctrl: boolean, alt: boolean) {\n        if(this.driver === null)\n            return;\n\n        // Get origin and direction. Using a temporary raycaster\n        this.raycaster.setFromCamera(\n            { x: xNorm * 2 - 1, y: 1 - yNorm * 2 },\n            this.raycaster.camera,\n        );\n\n        // Cast ray\n        this.driver.handlePointerRay(\n            this._pointer,\n            pressing,\n            this.raycaster.ray.origin.toArray(),\n            this.raycaster.ray.direction.toArray(),\n            shift,\n            ctrl,\n            alt,\n        );\n    }\n\n    setRayPointerDriver(driver: RayPointerDriver): void {\n        // If driver already set, unset old driver\n        if(this.driver !== null)\n            this.clearRayPointerDriver();\n\n        // Register pointer\n        this._pointer = driver.registerPointer();\n\n        // Set driver\n        this.driver = driver;\n    }\n\n    clearRayPointerDriver(): void {\n        // Unregister pointer\n        if(this._pointer !== -1)\n            this.driver?.unregisterPointer(this._pointer);\n\n        // Unset driver and pointer\n        this.driver = null;\n        this._pointer = -1;\n    }\n\n    // Can be ignored, since mouse styling is done via pointer styles\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onPointerHintChanged(_pointer: number, _hint: PointerHint): void {}\n}", "import { /* tree-shaking no-side-effects-when-called */ Raycaster, Ray, Vector3, Object3D, Camera } from 'three';\nimport { RayPointerDriver } from '@rafern/canvas-ui';\nimport { ThreeRoot } from '../core/ThreeRoot';\n\nexport class ThreeRayPointerDriver extends RayPointerDriver {\n    private readonly raycaster: Raycaster = new Raycaster();\n\n    constructor(camera: Camera) {\n        super();\n\n        this.raycaster.camera = camera;\n    }\n\n    castRay(origin: [number, number, number], direction: [number, number, number]): [ThreeRoot | null, number, number] {\n        // Setup raycaster\n        this.raycaster.ray = new Ray(\n            new Vector3(...origin), new Vector3(...direction),\n        );\n\n        // Find intersection with any of the tracked roots\n        const meshRoots: Map<Object3D, ThreeRoot> = new Map();\n        for(const root of this.states.keys()) {\n            // Ignore roots that are not ThreeRoots; we need their meshes\n            if(root instanceof ThreeRoot)\n                meshRoots.set(root.mesh.children[0], root);\n        }\n\n        const meshes = Array.from(meshRoots.keys());\n        const intersections = this.raycaster.intersectObjects(meshes);\n        if(intersections.length === 0)\n            return [null, 0, 0];\n\n        // Pick the closest valid intersection\n        for(const intersection of intersections) {\n            const uv = intersection.uv;\n\n            if(typeof uv === 'undefined')\n                continue;\n\n            const root = meshRoots.get(intersection.object);\n            if(typeof root === 'undefined')\n                continue;\n\n            return [root, uv.x, 1 - uv.y];\n        }\n\n        // None of the intersections were valid (missing uv or root)\n        return [null, 0, 0];\n    }\n}\n", "import type { RayPointerSource, RayPointerDriver } from '@rafern/canvas-ui';\nimport type { Group, XRInputSource, WebXRManager } from 'three';\nimport { PointerHint } from '@rafern/canvas-ui';\nimport { Vector3 } from 'three';\n\nexport interface XRControllerSourceState {\n    source: XRInputSource | null;\n    pointer: number;\n}\n\nexport class XRControllerRayPointerSource implements RayPointerSource {\n    private _controllers: Map<Group, XRControllerSourceState> = new Map();\n    private driver: RayPointerDriver | null = null;\n\n    constructor(webXRManager: WebXRManager) {\n        // Keep track of first 2 controllers as they should be enough\n        this.trackController(webXRManager.getController(0));\n        this.trackController(webXRManager.getController(1));\n    }\n\n    get controllers(): IterableIterator<[Group, XRControllerSourceState]> {\n        return this._controllers.entries();\n    }\n\n    private trackController(controller: Group) {\n        // Create state for new tracked controller\n        const state = <XRControllerSourceState>{\n            source: null,\n            pointer: -1\n        };\n\n        this._controllers.set(controller, state);\n\n        // Add event listeners\n        controller.addEventListener('connected', event => {\n            state.source = event.data;\n            this.registerController(state);\n        });\n        controller.addEventListener('disconnected', _event => {\n            state.source = null;\n            this.unregisterController(state);\n        });\n        controller.addEventListener('move', _event => {\n            // Send pointer rays if state and driver are valid\n            if(state.source !== null && state.pointer !== -1 && this.driver !== null) {\n                const direction = new Vector3(0, 0, -1).applyQuaternion(controller.quaternion);\n                const origin = new Vector3();\n                controller.getWorldPosition(origin);\n\n                let buttonBits = 0;\n                const buttons = state.source.gamepad.buttons;\n                for(const buttonID in buttons) {\n                    const bit = parseInt(buttonID, 10);\n                    if(!isNaN(bit) && buttons[bit].pressed)\n                        buttonBits |= 1 << bit;\n                }\n\n                this.driver.handlePointerRay(\n                    state.pointer,\n                    buttonBits,\n                    origin.toArray(),\n                    direction.toArray(),\n                    false,\n                    false,\n                    false,\n                )\n            }\n        })\n\n        // Add default hint\n        controller.userData.pointerHint = PointerHint.None;\n    }\n\n    private registerController(state: XRControllerSourceState) {\n        // Register pointer and save pointer ID\n        if(this.driver !== null && state.source !== null && state.pointer === -1)\n            state.pointer = this.driver.registerPointer();\n    }\n\n    private unregisterController(state: XRControllerSourceState) {\n        // Unregister pointer\n        if(this.driver !== null && state.pointer !== -1)\n            this.driver.unregisterPointer(state.pointer);\n\n        // Unset pointer ID to prevent double-unregistering\n        state.pointer = -1;\n    }\n\n    setRayPointerDriver(driver: RayPointerDriver): void {\n        // If driver already set, unset old driver\n        if(this.driver !== null)\n            this.clearRayPointerDriver();\n\n        // Register controllers\n        for(const state of this._controllers.values())\n            this.registerController(state);\n\n        // Set driver\n        this.driver = driver;\n    }\n\n    clearRayPointerDriver(): void {\n        // Unregister pointers for each controller\n        for(const state of this._controllers.values())\n            this.unregisterController(state);\n\n        // Unset driver\n        this.driver = null;\n    }\n\n    onPointerHintChanged(pointer: number, hint: PointerHint): void {\n        // Only set controller's pointer hint if pointer ID is owned by this\n        // source\n        // XXX this seems inneficient, but the amount of controllers is so\n        // small that it shouldn't matter. if it gets bad, use a bi-map\n        for(const [controller, state] of this._controllers) {\n            if(state.pointer === pointer)\n                controller.userData.pointerHint = hint;\n        }\n    }\n}"],
  "mappings": "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",
  "names": []
}
