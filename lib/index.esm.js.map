{
  "version": 3,
  "sources": ["../src/core/ThreeRoot.ts", "../src/core/ThreeVirtualKeyboardRoot.ts", "../src/drivers/MouseRayPointerSource.ts", "../src/drivers/ThreeRayPointerDriver.ts", "../src/drivers/XRControllerRayPointerSource.ts"],
  "sourcesContent": ["import type { Widget, RootProperties } from '@rafern/canvas-ui';\nimport type { TransformAlgorithm } from './TransformAlgorithm';\nimport { Root } from '@rafern/canvas-ui';\n\nimport {\n    CanvasTexture, PlaneGeometry, MeshBasicMaterial, Mesh, Vector2, Object3D\n} from 'three';\n\n/**\n * Optional ThreeRoot constructor properties.\n *\n * @category Core\n */\nexport interface ThreeRootProperties extends RootProperties {\n    /** Sets {@link ThreeRoot#transformAlgorithm}. */\n    transformAlgorithm?: TransformAlgorithm | null;\n}\n\n/**\n * A {@link Root} that also manages a three.js Mesh so that it can be added to a\n * Scene.\n *\n * @category Core\n */\nexport class ThreeRoot extends Root {\n    /** The texture with the canvas data. */\n    private texture: CanvasTexture;\n    /**\n     * The textured Mesh to be used for a Scene. Not actually a Mesh, but an\n     * Object3D which contains a mesh so that the mesh can be resized without\n     * interfering with the {@link transformAlgorithm}.\n     */\n    readonly mesh: Object3D;\n    /**\n     * Transform algorithm; decides how to position the canvas' mesh in the\n     * world. Can be changed later and is called on update.\n     */\n    transformAlgorithm: TransformAlgorithm | null;\n\n    /**\n     * Creates a new ThreeRoot.\n     *\n     * Sets {@link child}, {@link pointerStyleHandler},\n     * {@link transformAlgorithm} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}.\n     */\n    constructor(child: Widget, properties?: ThreeRootProperties) {\n        super(child, properties);\n\n        // Create texture out of canvas. For now, the texture is invalid\n        this.texture = new CanvasTexture(this.viewport.canvas);\n\n        // Create a planar mesh out of internal canvas\n        const meshGeometry = new PlaneGeometry();\n        const meshMaterial = new MeshBasicMaterial({ map: this.texture });\n        meshMaterial.transparent = true;\n        const internalMesh = new Mesh(meshGeometry, meshMaterial);\n\n        // Wrap mesh in Object3D so it can be transformed independently\n        this.mesh = new Object3D();\n        this.mesh.add(internalMesh);\n\n        // Transforms algorithm\n        this.transformAlgorithm = properties?.transformAlgorithm ?? null;\n    }\n\n    override set enabled(enabled: boolean) {\n        super.enabled = enabled;\n        this.mesh.visible = enabled;\n    }\n\n    override get enabled(): boolean {\n        return super.enabled;\n    }\n\n    override resolveLayout(): boolean {\n        const resized = super.resolveLayout();\n\n        // Resize mesh and texture if needed\n        if(resized) {\n            let [width, height] = this.dimensions;\n            // Round width and height down to avoid blurry canvas textures\n            width = Math.floor(width);\n            height = Math.floor(height);\n            const [canvasWidth, canvasHeight] = this.canvasDimensions;\n            const [scaleX, scaleY] = this.effectiveScale;\n            const u = scaleX * width / canvasWidth;\n            const v = scaleY * height / canvasHeight;\n            this.texture.offset = new Vector2(0, 1 - v);\n            this.texture.repeat = new Vector2(u, v);\n\n            this.mesh.children[0].scale.fromArray([width, height, 1]);\n        }\n\n        return resized;\n    }\n\n    override paint(): boolean {\n        const wasDirty = super.paint();\n\n        // Update texture if needed\n        if(wasDirty)\n            this.texture.needsUpdate = true;\n\n        // Update transforms of mesh\n        if(this.transformAlgorithm !== null) {\n            this.transformAlgorithm(this);\n\n            // Update mesh world matrix\n            this.mesh.matrixWorldNeedsUpdate = true;\n        }\n\n        return wasDirty;\n    }\n}\n", "import { KeyboardDriver, VirtualKeyboardRootProperties, Margin } from '@rafern/canvas-ui';\nimport { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '@rafern/canvas-ui';\nimport { ThreeRoot, ThreeRootProperties } from './ThreeRoot';\n\n/**\n * A {@link VirtualKeyboardRoot} but it extends {@link ThreeRoot} instead of\n * {@link Root}, so it can be used for three.js.\n *\n * @category Core\n */\nexport class ThreeVirtualKeyboardRoot extends ThreeRoot {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new ThreeVirtualKeyboardRoot.\n     *\n     * Sets {@link child} to a new {@link VirtualKeyboard} with the given\n     * keyboard and {@link VirtualKeyboardTemplate | keyboard template},\n     * {@link pointerStyleHandler}, {@link transformAlgorithm} and\n     * {@link child}'s {@link Widget.inheritedTheme | inherited theme}.\n     */\n    constructor(keyboardDriver: KeyboardDriver, properties?: VirtualKeyboardRootProperties & ThreeRootProperties) {\n        super(\n            new Margin(\n                new VirtualKeyboard(\n                    keyboardDriver,\n                    properties?.keyboardTemplate ?? defaultVirtualKeyboardTemplate\n                ),\n            ),\n            properties\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update the visibility of this root; if the keyboard driver has no focused\n     * root, then the root is disabled, else, it is enabled. Call this method\n     * on every frame to automatically enable/disable the root if needed\n     */\n    updateVisibility(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.needsInput;\n    }\n}", "import { /* tree-shaking no-side-effects-when-called */ Raycaster, Camera } from 'three';\nimport type { RayPointerSource, RayPointerDriver, PointerHint } from '@rafern/canvas-ui';\nimport { getPointerEventNormPos } from '@rafern/canvas-ui';\n\nexport class MouseRayPointerSource implements RayPointerSource {\n    private raycaster: Raycaster = new Raycaster();\n    private driver: RayPointerDriver | null = null;\n    /** The mapping between each DOM pointer ID and canvas-ui pointer ID */\n    private pointers: Map<number, number> = new Map();\n    /**\n     * The pointer ID of the mouse. Registered in constructor. This is needed\n     * due to wheel events not being part of the DOM PointerEvent interface and\n     * therefore not having a pointerID field. This is also safe because there\n     * can only be one mouse.\n     */\n    private mousePointerID: number | null = null;\n\n    constructor(camera: Camera, domElem: HTMLElement) {\n        this.raycaster.camera = camera;\n\n        // Add listeners to DOM element\n        const pointerEventHandler = (event: PointerEvent) => {\n            const pointer = this.getPointerID(event);\n            if(pointer === null)\n                return;\n\n            this.castRay(\n                pointer, ...getPointerEventNormPos(event, domElem),\n                event.buttons, event.shiftKey, event.ctrlKey, event.altKey,\n            );\n        };\n\n        domElem.addEventListener('pointermove', pointerEventHandler);\n        domElem.addEventListener('pointerdown', pointerEventHandler);\n        domElem.addEventListener('pointerup', pointerEventHandler);\n\n        domElem.addEventListener('pointerleave', (event: PointerEvent) => {\n            const pointer = this.getPointerID(event);\n            if(this.driver !== null && pointer !== null)\n                this.driver.leaveAnyPointer(pointer);\n        });\n\n        domElem.addEventListener('wheel', (event: WheelEvent) => {\n            if(this.mousePointerID === null || this.driver === null)\n                return;\n\n            const [screenXNorm, screenYNorm] = getPointerEventNormPos(event, domElem);\n            const [root, xNorm, yNorm] = this.driver.castRay(\n                ...this.getCastOriginDirection(screenXNorm, screenYNorm)\n            );\n\n            if(root === null)\n                return;\n\n            this.driver?.wheelPointer(\n                root, this.mousePointerID, xNorm, yNorm, event.deltaX,\n                event.deltaY, event.deltaZ, event.deltaMode, event.shiftKey,\n                event.ctrlKey, event.altKey,\n            );\n        });\n    }\n\n    private getCastOriginDirection(xNorm: number, yNorm: number): [[number, number, number], [number, number, number]] {\n        // Get origin and direction. Using a temporary raycaster\n        this.raycaster.setFromCamera(\n            { x: xNorm * 2 - 1, y: 1 - yNorm * 2 },\n            this.raycaster.camera,\n        );\n\n        return [\n            this.raycaster.ray.origin.toArray(),\n            this.raycaster.ray.direction.toArray(),\n        ]\n    }\n\n    private castRay(pointer: number, xNorm: number, yNorm: number, pressing: number | null, shift: boolean, ctrl: boolean, alt: boolean) {\n        if(this.driver === null)\n            return;\n\n        this.driver.handlePointerRay(\n            pointer,\n            pressing,\n            ...this.getCastOriginDirection(xNorm, yNorm),\n            shift,\n            ctrl,\n            alt,\n        );\n    }\n\n    setRayPointerDriver(driver: RayPointerDriver): void {\n        // If driver already set, unset old driver\n        if(this.driver !== null)\n            this.clearRayPointerDriver();\n\n        // Register mouse pointer\n        this.mousePointerID = driver.registerPointer(false);\n\n        // Set driver\n        this.driver = driver;\n    }\n\n    clearRayPointerDriver(): void {\n        // Unregister pointers\n        if(this.mousePointerID !== null)\n            this.driver?.unregisterPointer(this.mousePointerID);\n\n        for(const pointer of this.pointers.values())\n            this.driver?.unregisterPointer(pointer);\n\n        // Unset driver and pointers\n        this.driver = null;\n        this.mousePointerID = null;\n        this.pointers.clear();\n    }\n\n    // Can be ignored, since mouse styling is done via pointer styles\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onPointerHintChanged(_pointer: number, _hint: PointerHint): void {}\n\n    /**\n     * Get the canvas-ui pointer ID of a given event. If the event has a pointer\n     * which hasn't been registered yet, then it is registered automatically. If\n     * driver is null and therefore registering is impossible, null is returned.\n     */\n    private getPointerID(event: PointerEvent): number | null {\n        let pointerID: number | null | undefined = this.pointers.get(event.pointerId);\n\n        if(typeof pointerID === 'undefined') {\n            pointerID = event.pointerType === 'mouse' ? this.mousePointerID\n                                                      : null;\n\n            if(pointerID === null) {\n                if(this.driver === null)\n                    return null;\n\n                pointerID = this.driver.registerPointer(true);\n            }\n\n            this.pointers.set(event.pointerId, pointerID);\n        }\n\n        return pointerID;\n    }\n\n    /** Get the mouse pointer ID */\n    get mouseID(): number | null {\n        return this.mousePointerID;\n    }\n\n    /** Get all registered pointer IDs */\n    get pointerIDs(): Array<number> {\n        const ids = [];\n\n        if(this.mousePointerID !== null)\n            ids.push(this.mousePointerID);\n\n        for(const pointer of this.pointers.values())\n            ids.push(pointer);\n\n        return ids;\n    }\n}", "import { /* tree-shaking no-side-effects-when-called */ Raycaster, Ray, Vector3, Object3D, Camera } from 'three';\nimport { RayPointerDriver } from '@rafern/canvas-ui';\nimport { ThreeRoot } from '../core/ThreeRoot';\n\nexport class ThreeRayPointerDriver extends RayPointerDriver {\n    private readonly raycaster: Raycaster = new Raycaster();\n\n    constructor(camera: Camera) {\n        super();\n\n        this.raycaster.camera = camera;\n    }\n\n    castRay(origin: [number, number, number], direction: [number, number, number]): [ThreeRoot | null, number, number] {\n        // Setup raycaster\n        this.raycaster.ray = new Ray(\n            new Vector3(...origin), new Vector3(...direction),\n        );\n\n        // Find intersection with any of the tracked roots\n        const meshRoots: Map<Object3D, ThreeRoot> = new Map();\n        for(const root of this.states.keys()) {\n            // Ignore roots that are not ThreeRoots; we need their meshes\n            if(root instanceof ThreeRoot)\n                meshRoots.set(root.mesh.children[0], root);\n        }\n\n        const meshes = Array.from(meshRoots.keys());\n        const intersections = this.raycaster.intersectObjects(meshes);\n        if(intersections.length === 0)\n            return [null, 0, 0];\n\n        // Pick the closest valid intersection\n        for(const intersection of intersections) {\n            const uv = intersection.uv;\n\n            if(typeof uv === 'undefined')\n                continue;\n\n            const root = meshRoots.get(intersection.object);\n            if(typeof root === 'undefined')\n                continue;\n\n            return [root, uv.x, 1 - uv.y];\n        }\n\n        // None of the intersections were valid (missing uv or root)\n        return [null, 0, 0];\n    }\n}\n", "import type { RayPointerSource, RayPointerDriver } from '@rafern/canvas-ui';\nimport type { Group, WebXRManager } from 'three';\nimport { PointerHint } from '@rafern/canvas-ui';\nimport { Vector3 } from 'three';\n\nexport interface XRControllerSourceState {\n    source: XRInputSource | null;\n    pointer: number;\n}\n\nexport class XRControllerRayPointerSource implements RayPointerSource {\n    private _controllers: Map<Group, XRControllerSourceState> = new Map();\n    private driver: RayPointerDriver | null = null;\n\n    constructor(webXRManager: WebXRManager) {\n        // Keep track of first 2 controllers as they should be enough\n        this.trackController(webXRManager.getController(0));\n        this.trackController(webXRManager.getController(1));\n    }\n\n    get controllers(): IterableIterator<[Group, XRControllerSourceState]> {\n        return this._controllers.entries();\n    }\n\n    private trackController(controller: Group) {\n        // Create state for new tracked controller\n        const state = <XRControllerSourceState>{\n            source: null,\n            pointer: -1\n        };\n\n        this._controllers.set(controller, state);\n\n        // Add event listeners\n        controller.addEventListener('connected', event => {\n            state.source = event.data;\n            this.registerController(state);\n        });\n        controller.addEventListener('disconnected', _event => {\n            state.source = null;\n            this.unregisterController(state);\n        });\n        controller.addEventListener('move', _event => {\n            // Send pointer rays if state and driver are valid\n            if(state.source !== null && state.pointer !== -1 && this.driver !== null) {\n                const direction = new Vector3(0, 0, -1).applyQuaternion(controller.quaternion);\n                const origin = new Vector3();\n                controller.getWorldPosition(origin);\n\n                let buttonBits = 0;\n                if(state.source.gamepad) {\n                    const buttons = state.source.gamepad.buttons;\n                    for(const buttonID in buttons) {\n                        const bit = parseInt(buttonID, 10);\n                        if(!isNaN(bit) && buttons[bit].pressed)\n                            buttonBits |= 1 << bit;\n                    }\n                }\n\n                this.driver.handlePointerRay(\n                    state.pointer,\n                    buttonBits,\n                    origin.toArray(),\n                    direction.toArray(),\n                    false,\n                    false,\n                    false,\n                )\n            }\n        })\n\n        // Add default hint\n        controller.userData.pointerHint = PointerHint.None;\n    }\n\n    private registerController(state: XRControllerSourceState) {\n        // Register pointer and save pointer ID\n        if(this.driver !== null && state.source !== null && state.pointer === -1)\n            state.pointer = this.driver.registerPointer(true);\n    }\n\n    private unregisterController(state: XRControllerSourceState) {\n        // Unregister pointer\n        if(this.driver !== null && state.pointer !== -1)\n            this.driver.unregisterPointer(state.pointer);\n\n        // Unset pointer ID to prevent double-unregistering\n        state.pointer = -1;\n    }\n\n    setRayPointerDriver(driver: RayPointerDriver): void {\n        // If driver already set, unset old driver\n        if(this.driver !== null)\n            this.clearRayPointerDriver();\n\n        // Register controllers\n        for(const state of this._controllers.values())\n            this.registerController(state);\n\n        // Set driver\n        this.driver = driver;\n    }\n\n    clearRayPointerDriver(): void {\n        // Unregister pointers for each controller\n        for(const state of this._controllers.values())\n            this.unregisterController(state);\n\n        // Unset driver\n        this.driver = null;\n    }\n\n    onPointerHintChanged(pointer: number, hint: PointerHint): void {\n        // Only set controller's pointer hint if pointer ID is owned by this\n        // source\n        // XXX this seems inneficient, but the amount of controllers is so\n        // small that it shouldn't matter. if it gets bad, use a bi-map\n        for(const [controller, state] of this._controllers) {\n            if(state.pointer === pointer)\n                controller.userData.pointerHint = hint;\n        }\n    }\n}"],
  "mappings": "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",
  "names": ["Root", "CanvasTexture", "PlaneGeometry", "MeshBasicMaterial", "Mesh", "Vector2", "Object3D", "ThreeRoot", "child", "properties", "_a", "meshGeometry", "meshMaterial", "internalMesh", "enabled", "resized", "width", "height", "canvasWidth", "canvasHeight", "scaleX", "scaleY", "u", "v", "wasDirty", "Margin", "VirtualKeyboard", "defaultVirtualKeyboardTemplate", "ThreeVirtualKeyboardRoot", "ThreeRoot", "keyboardDriver", "properties", "_a", "Margin", "VirtualKeyboard", "defaultVirtualKeyboardTemplate", "Raycaster", "getPointerEventNormPos", "MouseRayPointerSource", "camera", "domElem", "pointerEventHandler", "event", "pointer", "_a", "screenXNorm", "screenYNorm", "root", "xNorm", "yNorm", "pressing", "shift", "ctrl", "alt", "driver", "_b", "_pointer", "_hint", "pointerID", "ids", "Raycaster", "Ray", "Vector3", "RayPointerDriver", "ThreeRayPointerDriver", "RayPointerDriver", "camera", "Raycaster", "origin", "direction", "Ray", "Vector3", "meshRoots", "root", "ThreeRoot", "meshes", "intersections", "intersection", "uv", "PointerHint", "Vector3", "XRControllerRayPointerSource", "webXRManager", "controller", "state", "event", "_event", "direction", "origin", "buttonBits", "buttons", "buttonID", "bit", "driver", "pointer", "hint"]
}
