import{Root as e,defaultTheme as r,defaultVirtualKeyboardTemplate as t,VirtualKeyboard as n,getPointerEventNormPos as s,RayPointerDriver as i,PointerHint as o}from"canvas-ui";import{CanvasTexture as a,PlaneGeometry as l,MeshBasicMaterial as c,Mesh as h,Object3D as u,Vector2 as d,Raycaster as v,Ray as p,Vector3 as y}from"three";class m extends e{constructor(e,t=null,n=null,s=r){super(e,t,s),this.texture=new a(this.viewport.canvas);const i=new l,o=new c({map:this.texture});o.transparent=!0;const d=new h(i,o);this.mesh=new u,this.mesh.add(d),this.transformAlgorithm=n}set enabled(e){super.enabled=e,this.mesh.visible=e}get enabled(){return super.enabled}resolveLayout(){const e=super.resolveLayout();if(e){const[e,r]=this.dimensions,[t,n]=this.canvasDimensions,s=e/t,i=r/n;this.texture.offset=new d(0,1-i),this.texture.repeat=new d(s,i),this.mesh.children[0].scale.fromArray([e,r,1])}return e}paint(){const e=super.paint();return e&&(this.texture.needsUpdate=!0),null!==this.transformAlgorithm&&(this.transformAlgorithm(this),this.mesh.matrixWorldNeedsUpdate=!0),e}}class g extends m{constructor(e,s=t,i=null,o=null,a=r){super(new n(e,s),i,o,a),this.keyboardDriver=e}updateVisibility(){this.enabled=null!==this.keyboardDriver.getFocusedRoot()}}class f{constructor(e,r){this.raycaster=new v,this.driver=null,this._pointer=-1,this.raycaster.camera=e,r.addEventListener("pointermove",(e=>{e.isPrimary&&this.castRay(...s(e,r))})),r.addEventListener("pointerdown",(e=>{e.isPrimary&&this.castRay(...s(e,r),!0)})),r.addEventListener("pointerup",(e=>{e.isPrimary&&this.castRay(...s(e,r),!1)})),r.addEventListener("pointerleave",(e=>{e.isPrimary&&null!==this.driver&&this.driver.leaveAnyPointer(this._pointer)}))}get pointer(){return-1===this._pointer?null:this._pointer}castRay(e,r,t=null){null!==this.driver&&(this.raycaster.setFromCamera({x:2*e-1,y:1-2*r},this.raycaster.camera),this.driver.handlePointerRay(this._pointer,t,this.raycaster.ray.origin.toArray(),this.raycaster.ray.direction.toArray()))}setRayPointerDriver(e){null!==this.driver&&this.clearRayPointerDriver(),this._pointer=e.registerPointer(),this.driver=e}clearRayPointerDriver(){var e;-1!==this._pointer&&(null===(e=this.driver)||void 0===e||e.unregisterPointer(this._pointer)),this.driver=null,this._pointer=-1}onPointerHintChanged(e,r){}}class w extends i{constructor(e){super(),this.raycaster=new v,this.raycaster.camera=e}castRay(e,r){this.raycaster.ray=new p(new y(...e),new y(...r));const t=new Map;for(const e of this.states.keys())e instanceof m?(console.log("root is a three root"),t.set(e.mesh,e)):console.warn("root is not a three root");const n=Array.from(t.keys()),s=this.raycaster.intersectObjects(n,!0);if(0===s.length)return console.warn("no intersections"),[null,0,0];for(const e of s){const r=e.uv;if(void 0===r){console.warn("intersection cancelled due to no uv");continue}const n=t.get(e.object);if(void 0!==n)return console.log("intersection",n,r.x,1-r.y),[n,r.x,1-r.y];console.warn("intersection cancelled due to no root from root")}return console.warn("no valid intersections"),[null,0,0]}}class P{constructor(e){this._controllers=new Map,this.driver=null,this.trackController(e.getController(0)),this.trackController(e.getController(1))}get controllers(){return this._controllers.entries()}trackController(e){const r={source:null,pointer:-1};this._controllers.set(e,r),e.addEventListener("connected",(e=>{r.source=e.data,this.registerController(r)})),e.addEventListener("disconnected",(e=>{r.source=null,this.unregisterController(r)})),e.addEventListener("move",(t=>{if(null!==r.source&&-1!==r.pointer&&null!==this.driver){const t=new y(0,0,-1).applyQuaternion(e.quaternion),n=new y;e.getWorldPosition(n),this.driver.handlePointerRay(r.pointer,r.source.gamepad.buttons[0].pressed,n.toArray(),t.toArray())}})),e.userData.pointerHint=o.None}registerController(e){null!==this.driver&&null!==e.source&&-1===e.pointer&&(e.pointer=this.driver.registerPointer())}unregisterController(e){null!==this.driver&&-1!==e.pointer&&this.driver.unregisterPointer(e.pointer),e.pointer=-1}setRayPointerDriver(e){null!==this.driver&&this.clearRayPointerDriver();for(const e of this._controllers.values())this.registerController(e);this.driver=e}clearRayPointerDriver(){for(const e of this._controllers.values())this.unregisterController(e);this.driver=null}onPointerHintChanged(e,r){for(const[t,n]of this._controllers)n.pointer===e&&(t.userData.pointerHint=r)}}export{f as MouseRayPointerSource,w as ThreeRayPointerDriver,m as ThreeRoot,g as ThreeVirtualKeyboardRoot,P as XRControllerRayPointerSource};
