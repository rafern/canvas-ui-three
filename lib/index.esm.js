import{Root as d}from"@rafern/canvas-ui";import{CanvasTexture as f,PlaneGeometry as v,MeshBasicMaterial as R,Mesh as b,Vector2 as m,Object3D as P}from"three";var a=class extends d{constructor(r,t=null,e=null,i){super(r,t,i);this.texture=new f(this.viewport.canvas);let n=new v,o=new R({map:this.texture});o.transparent=!0;let s=new b(n,o);this.mesh=new P,this.mesh.add(s),this.transformAlgorithm=e}set enabled(r){super.enabled=r,this.mesh.visible=r}get enabled(){return super.enabled}resolveLayout(){let r=super.resolveLayout();if(r){let[t,e]=this.dimensions,[i,n]=this.canvasDimensions,o=t/i,s=e/n;this.texture.offset=new m(0,1-s),this.texture.repeat=new m(o,s),this.mesh.children[0].scale.fromArray([t,e,1])}return r}paint(){let r=super.paint();return r&&(this.texture.needsUpdate=!0),this.transformAlgorithm!==null&&(this.transformAlgorithm(this),this.mesh.matrixWorldNeedsUpdate=!0),r}};import{VirtualKeyboard as g,defaultVirtualKeyboardTemplate as T}from"@rafern/canvas-ui";var D=class extends a{constructor(r,t=T,e=null,i=null,n){super(new g(r,t),e,i,n);this.keyboardDriver=r}updateVisibility(){this.enabled=this.keyboardDriver.getFocusedRoot()!==null}};import{Raycaster as x}from"three";import{getPointerEventNormPos as h}from"@rafern/canvas-ui";var C=class{constructor(r,t){this.raycaster=new x;this.driver=null;this._pointer=-1;this.raycaster.camera=r,t.addEventListener("pointermove",e=>{e.isPrimary&&this.castRay(...h(e,t),e.buttons,e.shiftKey,e.ctrlKey,e.altKey)}),t.addEventListener("pointerdown",e=>{e.isPrimary&&this.castRay(...h(e,t),e.buttons,e.shiftKey,e.ctrlKey,e.altKey)}),t.addEventListener("pointerup",e=>{e.isPrimary&&this.castRay(...h(e,t),e.buttons,e.shiftKey,e.ctrlKey,e.altKey)}),t.addEventListener("pointerleave",e=>{e.isPrimary&&this.driver!==null&&this.driver.leaveAnyPointer(this._pointer)})}get pointer(){return this._pointer===-1?null:this._pointer}castRay(r,t,e,i,n,o){this.driver!==null&&(this.raycaster.setFromCamera({x:r*2-1,y:1-t*2},this.raycaster.camera),this.driver.handlePointerRay(this._pointer,e,this.raycaster.ray.origin.toArray(),this.raycaster.ray.direction.toArray(),i,n,o))}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver(),this._pointer=r.registerPointer(),this.driver=r}clearRayPointerDriver(){var r;this._pointer!==-1&&((r=this.driver)==null||r.unregisterPointer(this._pointer)),this.driver=null,this._pointer=-1}onPointerHintChanged(r,t){}};import{Raycaster as S,Ray as w,Vector3 as p}from"three";import{RayPointerDriver as A}from"@rafern/canvas-ui";var _=class extends A{constructor(r){super();this.raycaster=new S;this.raycaster.camera=r}castRay(r,t){this.raycaster.ray=new w(new p(...r),new p(...t));let e=new Map;for(let o of this.states.keys())o instanceof a&&e.set(o.mesh.children[0],o);let i=Array.from(e.keys()),n=this.raycaster.intersectObjects(i);if(n.length===0)return[null,0,0];for(let o of n){let s=o.uv;if(typeof s=="undefined")continue;let u=e.get(o.object);if(typeof u!="undefined")return[u,s.x,1-s.y]}return[null,0,0]}};import{PointerHint as K}from"@rafern/canvas-ui";import{Vector3 as y}from"three";var H=class{constructor(r){this._controllers=new Map;this.driver=null;this.trackController(r.getController(0)),this.trackController(r.getController(1))}get controllers(){return this._controllers.entries()}trackController(r){let t={source:null,pointer:-1};this._controllers.set(r,t),r.addEventListener("connected",e=>{t.source=e.data,this.registerController(t)}),r.addEventListener("disconnected",e=>{t.source=null,this.unregisterController(t)}),r.addEventListener("move",e=>{if(t.source!==null&&t.pointer!==-1&&this.driver!==null){let i=new y(0,0,-1).applyQuaternion(r.quaternion),n=new y;r.getWorldPosition(n);let o=0,s=t.source.gamepad.buttons;for(let u in s){let c=parseInt(u,10);!isNaN(c)&&s[c].pressed&&(o|=1<<c)}this.driver.handlePointerRay(t.pointer,o,n.toArray(),i.toArray(),!1,!1,!1)}}),r.userData.pointerHint=K.None}registerController(r){this.driver!==null&&r.source!==null&&r.pointer===-1&&(r.pointer=this.driver.registerPointer())}unregisterController(r){this.driver!==null&&r.pointer!==-1&&this.driver.unregisterPointer(r.pointer),r.pointer=-1}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver();for(let t of this._controllers.values())this.registerController(t);this.driver=r}clearRayPointerDriver(){for(let r of this._controllers.values())this.unregisterController(r);this.driver=null}onPointerHintChanged(r,t){for(let[e,i]of this._controllers)i.pointer===r&&(e.userData.pointerHint=t)}};export{C as MouseRayPointerSource,_ as ThreeRayPointerDriver,a as ThreeRoot,D as ThreeVirtualKeyboardRoot,H as XRControllerRayPointerSource};
//# sourceMappingURL=index.esm.js.map
