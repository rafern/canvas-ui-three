import{Root as f}from"@rafern/canvas-ui";import{CanvasTexture as y,PlaneGeometry as b,MeshBasicMaterial as P,Mesh as R,Vector2 as m,Object3D as g}from"three";var u=class extends f{constructor(r,e=null,o=null,t){super(r,e,t);this.texture=new y(this.viewport.canvas);let i=new b,n=new P({map:this.texture});n.transparent=!0;let s=new R(i,n);this.mesh=new g,this.mesh.add(s),this.transformAlgorithm=o}set enabled(r){super.enabled=r,this.mesh.visible=r}get enabled(){return super.enabled}resolveLayout(){let r=super.resolveLayout();if(r){let[e,o]=this.dimensions,[t,i]=this.canvasDimensions,n=e/t,s=o/i;this.texture.offset=new m(0,1-s),this.texture.repeat=new m(n,s),this.mesh.children[0].scale.fromArray([e,o,1])}return r}paint(){let r=super.paint();return r&&(this.texture.needsUpdate=!0),this.transformAlgorithm!==null&&(this.transformAlgorithm(this),this.mesh.matrixWorldNeedsUpdate=!0),r}};import{VirtualKeyboard as D,defaultVirtualKeyboardTemplate as T}from"@rafern/canvas-ui";var C=class extends u{constructor(r,e=T,o=null,t=null,i){super(new D(r,e),o,t,i);this.keyboardDriver=r}updateVisibility(){this.enabled=this.keyboardDriver.getFocusedRoot()!==null}};import{Raycaster as x}from"three";import{getPointerEventNormPos as p}from"@rafern/canvas-ui";var w=class{constructor(r,e){this.raycaster=new x;this.driver=null;this.pointers=new Map;this.mousePointerID=null;this.raycaster.camera=r;let o=t=>{let i=this.getPointerID(t);i!==null&&this.castRay(i,...p(t,e),t.buttons,t.shiftKey,t.ctrlKey,t.altKey)};e.addEventListener("pointermove",o),e.addEventListener("pointerdown",o),e.addEventListener("pointerup",o),e.addEventListener("pointerleave",t=>{let i=this.getPointerID(t);this.driver!==null&&i!==null&&this.driver.leaveAnyPointer(i)}),e.addEventListener("wheel",t=>{var h;if(this.mousePointerID===null||this.driver===null)return;let[i,n]=p(t,e),[s,a,l]=this.driver.castRay(...this.getCastOriginDirection(i,n));s!==null&&((h=this.driver)==null||h.wheelPointer(s,this.mousePointerID,a,l,t.deltaX,t.deltaY,t.shiftKey,t.ctrlKey,t.altKey))})}getCastOriginDirection(r,e){return this.raycaster.setFromCamera({x:r*2-1,y:1-e*2},this.raycaster.camera),[this.raycaster.ray.origin.toArray(),this.raycaster.ray.direction.toArray()]}castRay(r,e,o,t,i,n,s){this.driver!==null&&this.driver.handlePointerRay(r,t,...this.getCastOriginDirection(e,o),i,n,s)}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver(),this.mousePointerID=r.registerPointer(!1),this.driver=r}clearRayPointerDriver(){var r,e;this.mousePointerID!==null&&((r=this.driver)==null||r.unregisterPointer(this.mousePointerID));for(let o of this.pointers.values())(e=this.driver)==null||e.unregisterPointer(o);this.driver=null,this.mousePointerID=null,this.pointers.clear()}onPointerHintChanged(r,e){}getPointerID(r){let e=this.pointers.get(r.pointerId);if(typeof e=="undefined"){if(e=r.pointerType==="mouse"?this.mousePointerID:null,e===null){if(this.driver===null)return null;e=this.driver.registerPointer(!0)}this.pointers.set(r.pointerId,e)}return e}};import{Raycaster as S,Ray as A,Vector3 as d}from"three";import{RayPointerDriver as I}from"@rafern/canvas-ui";var H=class extends I{constructor(r){super();this.raycaster=new S;this.raycaster.camera=r}castRay(r,e){this.raycaster.ray=new A(new d(...r),new d(...e));let o=new Map;for(let n of this.states.keys())n instanceof u&&o.set(n.mesh.children[0],n);let t=Array.from(o.keys()),i=this.raycaster.intersectObjects(t);if(i.length===0)return[null,0,0];for(let n of i){let s=n.uv;if(typeof s=="undefined")continue;let a=o.get(n.object);if(typeof a!="undefined")return[a,s.x,1-s.y]}return[null,0,0]}};import{PointerHint as K}from"@rafern/canvas-ui";import{Vector3 as v}from"three";var M=class{constructor(r){this._controllers=new Map;this.driver=null;this.trackController(r.getController(0)),this.trackController(r.getController(1))}get controllers(){return this._controllers.entries()}trackController(r){let e={source:null,pointer:-1};this._controllers.set(r,e),r.addEventListener("connected",o=>{e.source=o.data,this.registerController(e)}),r.addEventListener("disconnected",o=>{e.source=null,this.unregisterController(e)}),r.addEventListener("move",o=>{if(e.source!==null&&e.pointer!==-1&&this.driver!==null){let t=new v(0,0,-1).applyQuaternion(r.quaternion),i=new v;r.getWorldPosition(i);let n=0,s=e.source.gamepad.buttons;for(let a in s){let l=parseInt(a,10);!isNaN(l)&&s[l].pressed&&(n|=1<<l)}this.driver.handlePointerRay(e.pointer,n,i.toArray(),t.toArray(),!1,!1,!1)}}),r.userData.pointerHint=K.None}registerController(r){this.driver!==null&&r.source!==null&&r.pointer===-1&&(r.pointer=this.driver.registerPointer(!0))}unregisterController(r){this.driver!==null&&r.pointer!==-1&&this.driver.unregisterPointer(r.pointer),r.pointer=-1}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver();for(let e of this._controllers.values())this.registerController(e);this.driver=r}clearRayPointerDriver(){for(let r of this._controllers.values())this.unregisterController(r);this.driver=null}onPointerHintChanged(r,e){for(let[o,t]of this._controllers)t.pointer===r&&(o.userData.pointerHint=e)}};export{w as MouseRayPointerSource,H as ThreeRayPointerDriver,u as ThreeRoot,C as ThreeVirtualKeyboardRoot,M as XRControllerRayPointerSource};
//# sourceMappingURL=index.esm.js.map
