import{Root as v}from"@rafern/canvas-ui";import{CanvasTexture as y,PlaneGeometry as b,MeshBasicMaterial as P,Mesh as R,Vector2 as m,Object3D as g}from"three";var u=class extends v{constructor(r,e=null,o=null,t){super(r,e,t);this.texture=new y(this.viewport.canvas);let n=new b,i=new P({map:this.texture});i.transparent=!0;let s=new R(n,i);this.mesh=new g,this.mesh.add(s),this.transformAlgorithm=o}set enabled(r){super.enabled=r,this.mesh.visible=r}get enabled(){return super.enabled}resolveLayout(){let r=super.resolveLayout();if(r){let[e,o]=this.dimensions;e=Math.floor(e),o=Math.floor(o);let[t,n]=this.canvasDimensions,i=e/t,s=o/n;this.texture.offset=new m(0,1-s),this.texture.repeat=new m(i,s),this.mesh.children[0].scale.fromArray([e,o,1])}return r}paint(){let r=super.paint();return r&&(this.texture.needsUpdate=!0),this.transformAlgorithm!==null&&(this.transformAlgorithm(this),this.mesh.matrixWorldNeedsUpdate=!0),r}};import{VirtualKeyboard as D,defaultVirtualKeyboardTemplate as T}from"@rafern/canvas-ui";var C=class extends u{constructor(r,e=T,o=null,t=null,n){super(new D(r,e),o,t,n);this.keyboardDriver=r}updateVisibility(){this.enabled=this.keyboardDriver.getFocusedRoot()!==null}};import{Raycaster as x}from"three";import{getPointerEventNormPos as p}from"@rafern/canvas-ui";var I=class{constructor(r,e){this.raycaster=new x;this.driver=null;this.pointers=new Map;this.mousePointerID=null;this.raycaster.camera=r;let o=t=>{let n=this.getPointerID(t);n!==null&&this.castRay(n,...p(t,e),t.buttons,t.shiftKey,t.ctrlKey,t.altKey)};e.addEventListener("pointermove",o),e.addEventListener("pointerdown",o),e.addEventListener("pointerup",o),e.addEventListener("pointerleave",t=>{let n=this.getPointerID(t);this.driver!==null&&n!==null&&this.driver.leaveAnyPointer(n)}),e.addEventListener("wheel",t=>{var c;if(this.mousePointerID===null||this.driver===null)return;let[n,i]=p(t,e),[s,a,l]=this.driver.castRay(...this.getCastOriginDirection(n,i));s!==null&&((c=this.driver)==null||c.wheelPointer(s,this.mousePointerID,a,l,t.deltaX,t.deltaY,t.shiftKey,t.ctrlKey,t.altKey))})}getCastOriginDirection(r,e){return this.raycaster.setFromCamera({x:r*2-1,y:1-e*2},this.raycaster.camera),[this.raycaster.ray.origin.toArray(),this.raycaster.ray.direction.toArray()]}castRay(r,e,o,t,n,i,s){this.driver!==null&&this.driver.handlePointerRay(r,t,...this.getCastOriginDirection(e,o),n,i,s)}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver(),this.mousePointerID=r.registerPointer(!1),this.driver=r}clearRayPointerDriver(){var r,e;this.mousePointerID!==null&&((r=this.driver)==null||r.unregisterPointer(this.mousePointerID));for(let o of this.pointers.values())(e=this.driver)==null||e.unregisterPointer(o);this.driver=null,this.mousePointerID=null,this.pointers.clear()}onPointerHintChanged(r,e){}getPointerID(r){let e=this.pointers.get(r.pointerId);if(typeof e=="undefined"){if(e=r.pointerType==="mouse"?this.mousePointerID:null,e===null){if(this.driver===null)return null;e=this.driver.registerPointer(!0)}this.pointers.set(r.pointerId,e)}return e}get mouseID(){return this.mousePointerID}get pointerIDs(){let r=[];this.mousePointerID!==null&&r.push(this.mousePointerID);for(let e of this.pointers.values())r.push(e);return r}};import{Raycaster as w,Ray as S,Vector3 as d}from"three";import{RayPointerDriver as A}from"@rafern/canvas-ui";var M=class extends A{constructor(r){super();this.raycaster=new w;this.raycaster.camera=r}castRay(r,e){this.raycaster.ray=new S(new d(...r),new d(...e));let o=new Map;for(let i of this.states.keys())i instanceof u&&o.set(i.mesh.children[0],i);let t=Array.from(o.keys()),n=this.raycaster.intersectObjects(t);if(n.length===0)return[null,0,0];for(let i of n){let s=i.uv;if(typeof s=="undefined")continue;let a=o.get(i.object);if(typeof a!="undefined")return[a,s.x,1-s.y]}return[null,0,0]}};import{PointerHint as H}from"@rafern/canvas-ui";import{Vector3 as f}from"three";var K=class{constructor(r){this._controllers=new Map;this.driver=null;this.trackController(r.getController(0)),this.trackController(r.getController(1))}get controllers(){return this._controllers.entries()}trackController(r){let e={source:null,pointer:-1};this._controllers.set(r,e),r.addEventListener("connected",o=>{e.source=o.data,this.registerController(e)}),r.addEventListener("disconnected",o=>{e.source=null,this.unregisterController(e)}),r.addEventListener("move",o=>{if(e.source!==null&&e.pointer!==-1&&this.driver!==null){let t=new f(0,0,-1).applyQuaternion(r.quaternion),n=new f;r.getWorldPosition(n);let i=0,s=e.source.gamepad.buttons;for(let a in s){let l=parseInt(a,10);!isNaN(l)&&s[l].pressed&&(i|=1<<l)}this.driver.handlePointerRay(e.pointer,i,n.toArray(),t.toArray(),!1,!1,!1)}}),r.userData.pointerHint=H.None}registerController(r){this.driver!==null&&r.source!==null&&r.pointer===-1&&(r.pointer=this.driver.registerPointer(!0))}unregisterController(r){this.driver!==null&&r.pointer!==-1&&this.driver.unregisterPointer(r.pointer),r.pointer=-1}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver();for(let e of this._controllers.values())this.registerController(e);this.driver=r}clearRayPointerDriver(){for(let r of this._controllers.values())this.unregisterController(r);this.driver=null}onPointerHintChanged(r,e){for(let[o,t]of this._controllers)t.pointer===r&&(o.userData.pointerHint=e)}};export{I as MouseRayPointerSource,M as ThreeRayPointerDriver,u as ThreeRoot,C as ThreeVirtualKeyboardRoot,K as XRControllerRayPointerSource};
//# sourceMappingURL=index.esm.js.map
