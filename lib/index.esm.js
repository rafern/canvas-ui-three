import{Root as g}from"@rafern/canvas-ui";import{CanvasTexture as D,PlaneGeometry as R,MeshBasicMaterial as x,Mesh as C,Vector2 as m,Object3D as I}from"three";var u=class extends g{constructor(e,o){var n;super(e,o);this.texture=new D(this.viewport.canvas);let t=new R,i=new x({map:this.texture});i.transparent=!0;let s=new C(t,i);this.mesh=new I,this.mesh.add(s),this.transformAlgorithm=(n=o==null?void 0:o.transformAlgorithm)!=null?n:null}set enabled(e){super.enabled=e,this.mesh.visible=e}get enabled(){return super.enabled}resolveLayout(){let e=super.resolveLayout();if(e){let[o,t]=this.dimensions;o=Math.floor(o),t=Math.floor(t);let[i,s]=this.canvasDimensions,[n,l]=this.effectiveScale,a=n*o/i,c=l*t/s;this.texture.offset=new m(0,1-c),this.texture.repeat=new m(a,c),this.mesh.children[0].scale.fromArray([o,t,1])}return e}paint(){let e=super.paint();return e&&(this.texture.needsUpdate=!0),this.transformAlgorithm!==null&&(this.transformAlgorithm(this),this.mesh.matrixWorldNeedsUpdate=!0),e}};import{Margin as w}from"@rafern/canvas-ui";import{VirtualKeyboard as A,defaultVirtualKeyboardTemplate as M}from"@rafern/canvas-ui";var p=class extends u{constructor(e,o){var t;super(new w(new A(e,(t=o==null?void 0:o.keyboardTemplate)!=null?t:M)),o);this.keyboardDriver=e}updateVisibility(){this.enabled=this.keyboardDriver.needsInput}};import{Raycaster as S}from"three";import{getPointerEventNormPos as d}from"@rafern/canvas-ui";var f=class{constructor(r,e){this.raycaster=new S;this.driver=null;this.pointers=new Map;this.mousePointerID=null;this.raycaster.camera=r;let o=t=>{let i=this.getPointerID(t);i!==null&&this.castRay(i,...d(t,e),t.buttons,t.shiftKey,t.ctrlKey,t.altKey)};e.addEventListener("pointermove",o),e.addEventListener("pointerdown",o),e.addEventListener("pointerup",o),e.addEventListener("pointerleave",t=>{let i=this.getPointerID(t);this.driver!==null&&i!==null&&this.driver.leaveAnyPointer(i)}),e.addEventListener("wheel",t=>{var c;if(this.mousePointerID===null||this.driver===null)return;let[i,s]=d(t,e),[n,l,a]=this.driver.castRay(...this.getCastOriginDirection(i,s));n!==null&&((c=this.driver)==null||c.wheelPointer(n,this.mousePointerID,l,a,t.deltaX,t.deltaY,t.deltaZ,t.deltaMode,t.shiftKey,t.ctrlKey,t.altKey))})}getCastOriginDirection(r,e){return this.raycaster.setFromCamera({x:r*2-1,y:1-e*2},this.raycaster.camera),[this.raycaster.ray.origin.toArray(),this.raycaster.ray.direction.toArray()]}castRay(r,e,o,t,i,s,n){this.driver!==null&&this.driver.handlePointerRay(r,t,...this.getCastOriginDirection(e,o),i,s,n)}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver(),this.mousePointerID=r.registerPointer(!1),this.driver=r}clearRayPointerDriver(){var r,e;this.mousePointerID!==null&&((r=this.driver)==null||r.unregisterPointer(this.mousePointerID));for(let o of this.pointers.values())(e=this.driver)==null||e.unregisterPointer(o);this.driver=null,this.mousePointerID=null,this.pointers.clear()}onPointerHintChanged(r,e){}getPointerID(r){let e=this.pointers.get(r.pointerId);if(typeof e=="undefined"){if(e=r.pointerType==="mouse"?this.mousePointerID:null,e===null){if(this.driver===null)return null;e=this.driver.registerPointer(!0)}this.pointers.set(r.pointerId,e)}return e}get mouseID(){return this.mousePointerID}get pointerIDs(){let r=[];this.mousePointerID!==null&&r.push(this.mousePointerID);for(let e of this.pointers.values())r.push(e);return r}};import{Raycaster as T,Ray as K,Vector3 as v}from"three";import{RayPointerDriver as H}from"@rafern/canvas-ui";var y=class extends H{constructor(e){super();this.raycaster=new T;this.raycaster.camera=e}castRay(e,o){this.raycaster.ray=new K(new v(...e),new v(...o));let t=new Map;for(let n of this.states.keys())n instanceof u&&t.set(n.mesh.children[0],n);let i=Array.from(t.keys()),s=this.raycaster.intersectObjects(i);if(s.length===0)return[null,0,0];for(let n of s){let l=n.uv;if(typeof l=="undefined")continue;let a=t.get(n.object);if(typeof a!="undefined")return[a,l.x,1-l.y]}return[null,0,0]}};import{PointerHint as L}from"@rafern/canvas-ui";import{Vector3 as b}from"three";var P=class{constructor(r){this._controllers=new Map;this.driver=null;this.trackController(r.getController(0)),this.trackController(r.getController(1))}get controllers(){return this._controllers.entries()}trackController(r){let e={source:null,pointer:-1};this._controllers.set(r,e),r.addEventListener("connected",o=>{e.source=o.data,this.registerController(e)}),r.addEventListener("disconnected",o=>{e.source=null,this.unregisterController(e)}),r.addEventListener("move",o=>{if(e.source!==null&&e.pointer!==-1&&this.driver!==null){let t=new b(0,0,-1).applyQuaternion(r.quaternion),i=new b;r.getWorldPosition(i);let s=0;if(e.source.gamepad){let n=e.source.gamepad.buttons;for(let l in n){let a=parseInt(l,10);!isNaN(a)&&n[a].pressed&&(s|=1<<a)}}this.driver.handlePointerRay(e.pointer,s,i.toArray(),t.toArray(),!1,!1,!1)}}),r.userData.pointerHint=L.None}registerController(r){this.driver!==null&&r.source!==null&&r.pointer===-1&&(r.pointer=this.driver.registerPointer(!0))}unregisterController(r){this.driver!==null&&r.pointer!==-1&&this.driver.unregisterPointer(r.pointer),r.pointer=-1}setRayPointerDriver(r){this.driver!==null&&this.clearRayPointerDriver();for(let e of this._controllers.values())this.registerController(e);this.driver=r}clearRayPointerDriver(){for(let r of this._controllers.values())this.unregisterController(r);this.driver=null}onPointerHintChanged(r,e){for(let[o,t]of this._controllers)t.pointer===r&&(o.userData.pointerHint=e)}};export{f as MouseRayPointerSource,y as ThreeRayPointerDriver,u as ThreeRoot,p as ThreeVirtualKeyboardRoot,P as XRControllerRayPointerSource};
//# sourceMappingURL=index.esm.js.map
